---
title: "Dynamic OpenAI Connectors & MCP Tools"
---

**1. Dynamic availability (via Service Deployment & UI Hooks)**: 

You deploy a [Service](../../services_room_containers/overview) that advertises one or more Connectors or MCP endpoints. The ChatBot UI pulls from the room/project’s services list and lets the user toggle which MCP servers/connectors to use for a given message.

> **Important:** the ChatBot must expose the MCP tool to enable this dynamic tool selection. You can use the CLI flag to include MCP:
>  ```bash bash
>  meshagent chatbot join \
>    --room=myroom \
>    --agent-name=agent \
>    --mcp     # <-- enables MCP tool so the UI can show available servers/connectors
>  ```

**2. Always-On (via Agent hooks)**:

You define the tools inside the agent (e.g., in `get_thread_toolkits`), so they are always available to that agent—no user selection required.

> Use **dynamic** when you want users to select tools per message or conversation. Similar to how you can toggle on tools in ChatGPT, Claude, etc. Use **always-on** when a specific agent should ship with a fixed set of tools. For example, if you are creating a support agent that should always have access to an internal MCP Server with ticket resolution information.

## How it works 
MeshAgent integrates with the OpenAI Responses API via the [`OpenAIResponsesAdapter`](../adapters/openai_responses_adapter). On each turn:
1. The adapter gathers the available toolkits. This can be a combination of always-on toolkits defined in the agent or toolkits that are available and dynamically added/removed by a user through the UI. 
2. Registers the toolkits with the Responses API so the model can invoke them during a turn
3. If the model calls a tool, the adapter handles invoking the tool execution, streaming results, and returning the final result for that turn

## Dynamic path
If you want users to dynamically select which tools an agent should use first define and deploy a project or room service for your connector or MCP Server. Next, ensure your app has the UI hooks set up so that it can display the available services to the users (this is automatically handled in MeshAgent Studio). Then call in a chatbot with MCP capabilities turned on so that it can use the deployed services. 

Packaging OpenAI Connectors and MCP Servers is similar, but the differences are... (maybe put something here about the MCPEndPointSpec fields and how that is similar/differnt for Connectors and MCP Servers?)

### Define and Connect an OpenAI Connector 
You can make OpenAI connectors available to a room/project by [packaging the service](../../services_room_containers/packaging_and_deploying/packaging) and [deploying the service](../../services_room_containers/packaging_and_deploying/deployment) with the applicable information for the connector. 

To use an OpenAI Connector you will need to register an OAuth API client and possibly register or verify the app associated with the OAuth API client. For additional details see the [OpenAI documentation](https://platform.openai.com/docs/guides/tools-connectors-mcp).

```yaml
kind: Service
version: v1
metadata:
  name: microsoft-teams-connector
  description: "Expose Microsoft Teams via OpenAI Connector"
ports:
- num: "*"
  type: http
  endpoints:
  - path: /
    mcp:
      label: "microsoft-teams-connector"
      description: "OpenAI Connector for Microsoft Teams"
      openai_connector_id: "connector_microsoftteams"
      oauth:
        client_id: "YOUR_CLIENT_ID"
        client_secret: "..."
        authorization_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/authorize"
        token_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/token"
        no_pkce: false                    # Optional: depends on if pkce is used
        scopes: ["User.Read", "Chat.Read", "ChannelMessage.Read.All"]
```

Once you've packaged the service and set up applicable secrets you can deploy it as a project or room service, then call a ChatBot with MCP enabled into the room. 

```bash bash
meshagent service create --file="meshagent.yaml" # optional --room=myroom
meshagent chatbot join --room=myroom --agent-name=agent --mcp 
# make sure room matches room you deployed to if deployed as a room service
```

Next go to MeshAgent Studio (or your app) and begin talking to the agent. You'll be able to toggle connectors and MCP servers on and off per message. 

### Define and Connect an MCP Server
When you want to use a public or self-hosted MCP server package it as an external service then deploy it to your project or room. 

For example, we'll create a service so our agent can use the [DeepWiki MCP Server](https://docs.devin.ai/work-with-devin/deepwiki-mcp) (no authentication/credentials required). This MCP server can connect to public repositories on GitHub and has three tools to read the structure of repositories, view the documentation about a repository, and ask questions about a repository. 

```yaml yaml
kind: Service
version: v1
metadata:
  name: mcp-deepwiki
  description: "Expose DeepWiki MCP server"
ports:
- num: 443                 # 443 for HTTPS external services; use 80 for HTTP
  type: http
  endpoints:
  - path: /mcp             # external.url + path are appended together
    mcp:
      label: "mcp-deepwiki"
      description: "MCP DeepWiki Tools"
external:
  url: "https://mcp.deepwiki.com"
```

Deploy it to your project or room and call a ChatBot with MCP support into the room:
```bash bash
meshagent service create --file "meshagent.yaml" # optional --room=myroom 
meshagent chatbot join --room=myroom --agent-name=agent --mcp 
```

The ChatBot will auto-detect MCP endpoints (and connectors) deployed to the project or room. In the UI, you can toggle mcp-deepwiki on for that conversation or for a specific message.

### Creating a ChatBot that can dynamically .. 
If you want to create a ChatBot that can dynamically use MCP servers just like the CLI ChatBot, you can expose the MCPToolkitBuilder so clients can request MCP access when needed. (clarify this)

```python Python
from meshagent.openai.tools.responses_adapter import MCPToolkitBuilder

class SupportAgent(ChatBot):
    async def get_thread_tool_providers(self, room, thread):
        providers = await super().get_thread_tool_providers(room, thread)
        providers.append(MCPToolkitBuilder())
        return providers
```

This will allow users in your app to decide which MCP servers they want to use for a message. 
