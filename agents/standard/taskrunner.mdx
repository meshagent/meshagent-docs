---
title: "TaskRunner"
---

A TaskRunner is the bridge that makes any **existing AI Agent built in your framework of choice work seamlessly with MeshAgent**. It is a base agent class designed with one core principle: **bring your own logic**. 

## Why TaskRunner Exists

Many developers already have agents built with their preferred frameworksâ€”whether that's Pydantic AI, LangChain, CrewAI, or custom implementations. TaskRunner eliminates the need to rewrite these agents. Instead, you simply wrap your existing agent with a TaskRunner and can instantly share, deploy, scale, and manage your agents in a cohesive way. 

## Core Components

A TaskRunner defines: 
- **Input Schema**: JSON schema describing what arguments your agent accepts
- **Output Schema**: JSON schema describing what your agent returns
- **Ask Method**: Your custom logic that processes inputs and returns results

A TaskRunner joins a MeshAgent Room and can be discovered and invoked from the [MeshAgent Studio](https://studio.meshagent.com) using the "Run Task..." menu option or using the ```room.agents.ask``` method on the API.

## Example: Integrating a Pydantic AI Agent

This example shows how to wrap an existing Pydantic AI translation agent with a MeshAgent TaskRunner. We extend the base TaskRunner class to create our TranslationTaskRunner with a defined input schema, output schema, and ask method. 

Copy this code into a file called ``translator.py``. You will need to create and export an ``ANTHROPIC_API_KEY`` first for this to run.

```python Python
import os
import json
import asyncio
import logging
from datetime import date, datetime
from meshagent.otel import otel_config
from meshagent.api.services import ServiceHost
from meshagent.agents import TaskRunner
from meshagent.api.messaging import TextResponse, JsonResponse

from pydantic_ai import Agent
from pydantic import BaseModel, Field, ConfigDict
from pydantic_ai.models.anthropic import AnthropicModel
from pydantic_ai.providers.anthropic import AnthropicProvider

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

otel_config(service_name="my-service")

service = ServiceHost(
    port=int(os.getenv("MESHAGENT_PORT","7777"))
)

# Define Inputs, Outputs, and Pydantic AI Agent for Translation
class TranslationInput(BaseModel):
    text:str = Field(..., description="Text to translate")
    model_config = ConfigDict(extra='forbid')

class TranslationResult(BaseModel):
    french_translation:str
    spanish_translation:str
    model_config = ConfigDict(extra='forbid')

translation_agent = Agent(
    model=AnthropicModel('claude-4-sonnet-20250514', provider=AnthropicProvider()), #pass API key from env variables
    deps_type=None,
    instructions=f"""
        # Role Background
        You are responsible for translating recent news announcements into other languages. You are exposed to a variety of topics beyond your knowledge cutoff date. The current date is: {date.today().strftime("%B %d, %Y")}

        # Task
        Provide two translations, one in French and one in Spanish.     
    """,
    output_type=TranslationResult
)

# Utility function
async def save_to_storage(room, path: str, data: bytes):
        handle = await room.storage.open(path=path, overwrite=True)
        await room.storage.write(handle=handle, data=data)
        await room.storage.close(handle=handle)

# Use Pydantic AI agent in a MeshAgent Room
@service.path("/translator")
class TranslationTaskRunner(TaskRunner):
    def __init__(self):
        super().__init__(
            name="Translator",
            description="An agent that translates text to French and Spanish",
            input_schema=TranslationInput.model_json_schema(),
            output_schema=TranslationResult.model_json_schema()
        )

    async def ask(self, *, context, arguments):
        room=context.room

        inputs = TranslationInput(**arguments)
        log.info(f"Translating Text: {inputs.text}")

        translations = await translation_agent.run(inputs.text)
        log.info(f"Translation Result: {translations.output}")

        # save results to room storage
        log.info(f"Translation completed, writing raw results to Room storage.")
        
        await save_to_storage(
            room=room,
            path=f"translations/{room.room_name}-translation-{datetime.now():%Y%m%dT%H%M%S}.json",
            data=json.dumps({"input_text": inputs.text, "translations": translations.output.model_dump()}, indent=2, ensure_ascii=False).encode("utf-8")
        )

        return translations.output.model_dump()

print(f"running on port {service.port}")
asyncio.run(service.run())

```
### Running the TaskRunner

**In your terminal**

Start your service locally. Be sure you are in an activated virtual environment where meshagent and pydantic_ai are installed: 

```bash bash
python translator.py
```

Next use the MeshAgent CLI to authenticate and call your agent into a Room:
```bash bash
meshagent setup # this will authenticate you 
meshagent call agent --url=http://localhost:7777/translator --room=translate --participant-name=translator
```

**In the Studio**
1. Go to [studio.meshagent.com](https://studio.meshagent.com) 
2. Enter the room, ``translate``
3. Click menu --> "Run Task"
4. Select "Translator" from the agent dropdown 
5. Enter the text to translate
6. Results appear and are saved to room storage under the "translations" folder 

**Invoking the TaskRunner Programmatically**

Instead of invoking the agent through the Studio, you can also run the agent through code like this: 

```python Python
import asyncio
import json
from typing import Dict, Any
from meshagent.api import RoomClient, websocket_protocol

async def call_agent(
    room_name: str, 
    agent_name: str, 
    arguments: Dict[str, Any], 
    participant_name: str = "api_client"
) -> Dict[str, Any]:
    """Call a MeshAgent agent with the given arguments."""
    async with RoomClient(
        protocol=websocket_protocol(
            participant_name=participant_name, 
            room_name=room_name
        )
    ) as room:
        result = await room.agents.ask(
            agent=agent_name, 
            arguments=arguments
        )
        # Extract JSON data from JsonBody response
        return result.json if hasattr(result, 'json') else result

async def main():
    # Call your translator
    result = await call_agent(
        room_name="translate",
        agent_name="Translator",
        arguments={"text": "Hello, how are you today?"}
    )
    
    print("Translation result:")
    print(json.dumps(result, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    asyncio.run(main())
```

## Prebuilt MeshAgent TaskRunners
MeshAgent provides pre-built agents that extend the TaskRunner class with additional capabilities like tool use and iterative reasoning. These built-in agents are automatically available in every MeshAgent room as ``meshagent.planner`` and ``meshagent.schema_planner``.

### meshagent.planner
A TaskRunner that uses structured planning and returns a text response. You provide it a prompt (and optionally tools), and it yields a simple text response in a fixed schema: ``{"result":"<text>"}``. 

Example without tools: 

```python Python
import asyncio
from meshagent.api import RoomClient, websocket_protocol

async def run_planner(room_name:str, prompt:str, participant_name:str="test_user"):
    """
    Run the Planner in a MeshAgent Room

    Args:
        room_name: Name of the room to connect to
        prompt: The user prompt to send to the agent 
        participant_name: Name to use as participant (defaults to "test_user")
    """
    try:
        async with RoomClient(
            protocol=websocket_protocol(
                participant_name=participant_name, 
                room_name=room_name
            )
        ) as room:
            response = await room.agents.ask(
                agent="meshagent.planner",
                arguments={
                    "prompt": prompt
                    }
                )
            return response
    except Exception as e:
        print(f"Connection failed: {e}")

asyncio.run(run_planner(room_name="test", prompt="Write a product description for a bluetooth speaker"))
```

When you call tools into the studio you can add them to the generic meshagent.planner which is automatically available in the room. The Planner will ask you for any necessary information and invoke the appropriate tool(s) to perform the task. This is a good way to test how the tools you've built work with agents. 

### meshagent.schema_planner
A TaskRunner that uses structured planning and returns a structured output. You provide both a prompt and an explicit JSON schema describing the desired output.

Example without tools: 
```python Python
import asyncio
from meshagent.api import RoomClient, websocket_protocol

async def run_schema_planner(room_name:str, prompt:str, output_schema:dict, participant_name:str="test_user"):
    """
    Run the Planner in a MeshAgent Room

    Args:
        room_name: Name of the room to connect to
        prompt: The user prompt to send to the agent
        output_schema: The structured output to use in the response 
        participant_name: Name to use as participant (defaults to "test_user")
    """
    try:
        async with RoomClient(
            protocol=websocket_protocol(
                participant_name=participant_name, 
                room_name=room_name
            )
        ) as room:
            response = await room.agents.ask(
                agent="meshagent.schema_planner",
                arguments={
                    "prompt": prompt,
                    "output_schema": output_schema
                }
            )
            return response
    except Exception as e:
        print(f"Connection failed: {e}")

product_schema = {
    "type": "object",
    "additionalProperties": False,
    "properties": {
        "title": {"type": "string"},
        "price": {"type": "number"},
        "features": {"type": "array", "items": {"type": "string"}},
        "description": {"type": "string"}
    },
    "required": ["title", "price", "features", "description"]
}

asyncio.run(run_schema_planner(room_name="test", prompt="Create a product listing for a bluetooth speaker", output_schema=product_schema))

```
Two preconfigured task runners are available by default in MeshAgent rooms. These are available as ```meshagent.planner``` and ```meshagent.schema_planner``` via the ```room.agents.ask``` api.
You can try them out in the Studio by selecting "Run Task..." from the menu. These built in agents can be useful helpers in your own apps. For example, when you invoke an agent inside the
MeshAgent Studio, the PlanningResponder is used to generate user interface on the fly and gather the required JSON data to pass as input when invoking an agent. Extending the base TaskRunner 
and providing a custom set of rules and tools is a great way to get a simple agent up and running quickly.


## Custom TaskRunners
You can customize the PlanningResponder with the following constructor parameters:

**requires:** a list of requirements for the agent. You can use RequiredSchema, RequiredToolkit to use toolkits and schemas that have been registered with the room with this agent.

**input_prompt:** Whether the planner should accept a prompt as input, if true, the input should be in the format ```{ "prompt" : "text" }```.

**output_schema:** a JSON schema that responses must conform to.

**llm_adapter:** a LLM adapter to use to integrate with a LLM. We recommend using the OpenAIResponsesAdapter from ```meshagent-openai```.

**toolkits:** used to specify local toolkits for the agent. While it's generally recommended to register toolkits with the room so any agent or user can use them, sometimes you need each agent to have it's own instance of a toolkit, for instance with synchorized document authoring.

**rules:** a set of rules that the task runner should use while executing. Rules are used to guide the behavior of the agent with system or developer prompts (optional).

**max_iterations:** the maximum number of iterations of the planning loop (optional).

**tool_adapter:** a custom tool adapter to use to transform tool responses into context messages (optional).

**supports_tools** Whether the agent should support passing a custom set of tools at runtime (optional)

## Using TaskRunner Agents as Tools
TaskRunners can also be surfaced in toolkits and used as tools that can be used by other agents using the RunTaskTool. Exposing agents as tools and then giving those tools to a ChatBot is a great way to get started building multi agent systems. 

The base TaskRunner requires JSON schemas to be provided to describe the input and output format. 