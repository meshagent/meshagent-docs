---
title: "Custom Logs, Traces, and Metrics"
---

import OtelExample from "/snippets/examples/python/deployable/observability/observability.mdx"
import OtelYAML from "/snippets/examples/python/deployable/observability/meshagent.mdx"
import ScratchDockerfile from "/snippets/examples/python/deployable/Dockerfile.mdx"

MeshAgent emits OpenTelemetry signals out of the box. When you need deeper insight, you can add your own spans, logs, and metrics using standard OTEL SDKs. This guide walks through a Weather Toolkit with custom intstrumentation so you can see the pieces in action. 

## Enable telemetry in your service
Add two lines at startup before you create your ``ServiceHost``: 

```python Python
from meshagent.otel import otel_config
otel_config(service_name="weather-service")
```

This initializes tracing, logging, and metrics and tags everything with your project/room/session so it shows up live in MeshAgent Studio.

## Example: Weather Toolkit with custom instrumentation
The example adds custom spans around validation, the external HTTP call, and response parsing. It also adds logs and metrics.

<CodeGroup>
    <OtelExample />
</CodeGroup>

### Custom Spans
Use spans to track a specific operation in trace. Spans can help you understand timing for each step and attach attributes/events to make debugging easier.

This example records: 
- ``toolkit.execute`` (created by MeshAgent) this is the high-level tool call including information about which tool was called and what information was passed to the tool
    - `validate_input` – checks city/units, adds events for pass/fail
    - `fetch_weather_api` – the external HTTP call with:
        - `http.url`, `http.method`, `http.status_code`, `http.response_size`
        - events like `api_request_start`, `api_request_success`, `api_timeout`, `rate_limit_exceeded`
    - `parse_response` – extracts the fields you return to the caller

Capturing additional information inside the (span/trace) created by MeshAgent allows us to capture finer-grained information about our process. 

**Pattern:**
```python Python
from opentelemetry import trace
from opentelemetry.trace import Status, StatusCode

tracer = trace.get_tracer(__name__)
with tracer.start_as_current_span("fetch_weather_api") as span:
    span.set_attribute("http.url", api_url)
    span.add_event("api_request_start")
    ...
    if resp.status_code == 429:
        span.set_status(Status(StatusCode.ERROR, "Rate limited"))
```
These show up in the room’s **Traces** tab.

### Custom Logs
``otel_config()`` sets up an OTEL logging handler so your normal logging.info() lines are captured. Add extra logs to make it easier to debug and understand...

```python Python
import logging
log = logging.getLogger(__name__)

log.info(f"Weather tool is running for city: {city} with units: {units}")
```

These show up in the room’s **Logs** tab.

### Custom Metrics
You can also add additional counters and historgrams to help track trends over time.

```python Python
from opentelemetry import metrics
meter = metrics.get_meter("weather.tools")

calls = meter.create_counter("weather.calls", unit="1",
                             description="Total weather tool invocations")

# When a call starts
calls.add(1, attributes={"city": city.lower(), "units": units})
```

These show up in the room’s **Metrics** tab.

## Running the sample
You can deploy and run this toolkit as a service and invoke the weather tool, `get_weather()`, from Studio or the CLI.

### Step 1: Package and deploy the room service
To deploy the otel service permanently, you'll package your code with a `meshagent.yaml` file that defines the service configuration and a container image that MeshAgent can run.
For full details on the service spec and deployment flow, see [Packaging and Deploying Services](../services_room_containers/packaging_and_deploying/packaging).

MeshAgent supports two deployment patterns for containers:
1. **Runtime image + code mount (recommended)**: Use a pre-built MeshAgent runtime image (like `python-sdk-slim`) that contains Python and all MeshAgent dependencies. Mount your lightweight code-only image on top. This keeps your code image tiny (~KB), eliminates dependency installation time, and allows your service to start quickly.
2. **Single Image**: Bundle your code and all dependencies into one image. This is good when you need extra libraries that aren't already in the runtime image, but can result in larger images and slower pulls.

This example demonstrates approach #1 with a code-only image. The default YAML points at the public `python-docs-examples` image so you can still run the documentation examples without building your own images. If you want to build and push your own code image, follow the steps below and update the image mount section of the `meshagent.yaml` file.

**Prepare your project structure**
This example organizes the tool code and configuration in the same folder, making each sample self-contained:

```bash
your-project/
├── Dockerfile                    # Shared by all samples
├── observability/
│   ├── observability.py
│   └── meshagent.yaml            # Config specific to this sample
└── another_sample/               # Other samples follow same pattern
    ├── another_sample.py
    └── meshagent.yaml
```

> **Note:** If you're building a single tool, you only need the `observability/` folder. The structure shown supports multiple samples sharing one Dockerfile.

**Step 1a: Build a Docker container**
Create a scratch Dockerfile and copy the files you want to run. This creates a minimal image containing only your code files.

<CodeGroup>
    <ScratchDockerfile />
</CodeGroup>

Build and push the image with `docker buildx`:

```bash bash
docker buildx build . \
  -t "<REGISTRY>/<NAMESPACE>/<IMAGE_NAME>:<TAG>" \
  --platform linux/amd64 \
  --push
```

> **Note:** Building from the project root copies your entire project structure into the image. For a single tool, this is fine - your image will just contain one folder. For multi-tool projects, all samples will be in one image, but each can deploy independently using its own `meshagent.yaml`.

**Step 1b: Package the service**
Define the service configuration in a `meshagent.yaml` file. This service will have a `container` section that references:

- Runtime image: The MeshAgent Python SDK image with all dependencies
- Code mount: Your code-only image mounted at /src
- Command path: Points to your sample's specific location

<CodeGroup>
    <OtelYAML />
</CodeGroup>

How the paths work:
- Your code image contains `/observability/observability.py`
- It's mounted at `/src` in the runtime container
- The command runs `python /src/observability/observability.py`

> Note: The default YAML in the docs uses `us-central1-docker.pkg.dev/meshagent-public/images/python-docs-examples` so you can test this example immediately without building your own image first. Replace this with your actual image tag when deploying your own code.

**Step 1c: Deploy the service**
Next from the CLI in the directory where your `meshagent.yaml` file is run:

```bash
meshagent service create --file "meshagent.yaml" --room=otel
```

### Step 2: Invoking the tool 
Once you've created the service you can invoke the tool directly from MeshAgent Studio by going into the room, clicking the menu icon, selecting **Toolkits**, then select the **Weather Tool** and click **Invoke**. The UI will display a dialog for you to input the city and units you want to get the weather from. 

You can also invoke the tool using the MeshAgent CLI:

```bash bash 
meshagent room agents invoke-tool \
  --room=otel \
  --toolkit=weather-toolkit \
  --tool=get_weather \
  --arguments='{"city":"Costa Mesa","units":"imperial"}'
```

## Viewing telemetry 
From [MeshAgent Studio](https://studio.meshagent.com) you will see Logs, Traces, and Metrics both from the **Session** view of the room and from the **Developer Console**. The **Session** viewer provides a focused view of session details which are accessible during and after each session. The **Developer Console** appears on the lower part of the screen once you're inside a room and shows live traces, logs, and metrics as you interact with your services inside a room.

After invoking the weather tool in this example you should see a trace tree appear in the **Traces** tab with a structure like this: 

```
toolkit.execute (get_weather)
 ├─ validate_input
 ├─ fetch_weather_api
 └─ parse_response
```

Applicable logs and metrics will appear under their respective tabs. 

## Next Steps
- [Agents](../agents/standard/intro): Understand how agents work in MeshAgent and start building your first one!
- [Tools](../agents/tools/intro): Learn how to build tools human and agent participants can use inside a MeshAgent room. 
- [Services & Containers](../services_room_containers/overview): Learn how to deploy instrumented agents and tools as project wide or room specific services in MeshAgent
