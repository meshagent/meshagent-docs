---
title: "MailWorker"
---

import CliMailbotYaml from "/snippets/examples/cli/mailbot/meshagent.mdx"
import SimpleMailbot from "/snippets/examples/python/agents/mailbot/mailbot.mdx"
import ProvisionMailbox from "/snippets/examples/python/agents/mailbot/provision_mailbox.mdx"

## Overview
`MailWorker` is the standard agent for building email-based workflows in MeshAgent. It extends [`Worker`](./worker) to process inbound email delivered to a room queue, store every message and attachment in room storage, rebuild thread context for the LLM, and send replies via SMTP. This turns a mailbox into a room-connected, tool-using email agent.

### Two ways to build a MailWorker
1. **CLI:** Run production-ready mail agents with a single command. Configure the email queue, mailbox, tools, and agent rules using CLI flags. Ideal for most use cases.
2. **SDK:** Extend the base `MailWorker` class with custom code when you need deeper integrations or specialized behaviors.

Both approaches deploy the same way and can operate together in the same Rooms. We recommend starting with the CLI, then moving to the SDK when you need additional custom logic.

### In this guide you will learn
- When to use `MailWorker`
- How to provision and manage mailboxes (Studio, CLI, or SDK)
- How to run and deploy a `MailWorker` with the MeshAgent CLI
- How to build and deploy a `MailWorker` with the MeshAgent SDK
- How `MailWorker` works, including constructor parameters, lifecycle, processing flow, hooks, and methods

## When to use MailWorker
Use `MailWorker` when you need an agent that:
- Responds to inbound email automatically (support, triage, order confirmations)
- Maintains threaded context across a mail conversation
- Runs LLM reasoning and tools over incoming email before replying
- Stores messages and attachments in room storage for auditing and follow-on workflows

Don't use `MailWorker` if:
- You need live text chat, use [ChatBot](./chatbot)
- You need speech, use [VoiceBot](./voicebot)
- You need background queue processing without email, use [Worker](./worker) or [TaskRunner](./taskrunner)

## Mailbox provisioning (required)
A mailbox maps an email address to a Room and queue. The `MailWorker` consumes that queue and sends replies from that address. Mailboxes can be managed from:
- **MeshAgent Studio** (recommended): create and assign mailboxes in the **Mail** tab
- **MeshAgent CLI:** Manage mailboxes with the `meshagent mailbox...` commands
- **SDK/REST:** Use the MeshAgent REST API to create, list, update, or delete mailboxes. 

Project admins (and developers with mail permissions) can create mailboxes. If you do not have access, ask an admin to provision one for you.

## Run and deploy a MailWorker with the CLI
### Step 1: Create a mailbox
Create a mailbox tied to a Room in [MeshAgent Studio](https://studio.meshagent.com), or use the CLI:

```bash bash
meshagent setup

# Fill in to careate a unique email address !
export EMAIL_ADDRESS="<your_unqiue_address>@mail.meshagent.com"
export EMAIL_QUEUE="<your_unqiue_address>"

meshagent mailbox create --address "$EMAIL_ADDRESS" --room quickstart --queue "$EMAIL_QUEUE"
```

You can list existing mailboxes with:

```bash bash
meshagent mailbox list
```

### Step 2: Run the mailbot
Start the built-in mailbot locally and connect it to your room:

```bash bash
meshagent mailbot join --room quickstart --agent-name mailbot \
  --queue "$EMAIL_QUEUE" --email-address "$EMAIL_ADDRESS"
```

Use flags like `--reply-all`, `--enable-attachments`, `--whitelist`, or `--room-rules` to customize behavior. Run `meshagent mailbot join --help` for the full list.

### Step 3: Send an email and verify
Send an email to the agent at the address you provisioned and it will respond! The agent will not show up in the participant list (mailbots are email-only) in MeshAgent Studio, but you can verify emails are received by checking:
- Logs in the Developer Console
- A `.emails/` folder in Files
- Metadata rows in the `emails` table

### Step 4: Package and deploy the agent
Once the mailbot works locally, deploy it as a service.

**Option 1: Deploy directly**
```bash bash
meshagent mailbot deploy --room quickstart --service-name mailbot --agent-name mailbot \
  --queue "$EMAIL_QUEUE" --email-address "$EMAIL_ADDRESS"
```

**Option 2: Generate a YAML spec**
```bash
meshagent mailbot spec --service-name mailbot --agent-name mailbot \
  --queue "$EMAIL_QUEUE" --email-address "$EMAIL_ADDRESS"
```

Copy the output into `meshagent.yaml`:

<CodeGroup>
    <CliMailbotYaml />
</CodeGroup>

Then deploy it:

```bash bash
meshagent service create --file meshagent.yaml --room quickstart
```

The `--room` flag is optional. Without it, the mailbot is deployed at the project level and appears in all rooms.

## Build and deploy a MailWorker with the SDK
The SDK approach produces the same deployed behavior as the CLI mailbot but lets you customize parsing, routing, toolkits, and reply logic.

### Step 1: Create a `MailWorker` agent
<CodeGroup>
    <SimpleMailbot />
</CodeGroup>

### Step 2: Provision a mailbox (if needed)
If you do not already have a mailbox, create one in Studio or via the CLI. To provision via SDK code:

```bash bash
meshagent api-key create --activate my-mailbot-key
```

```bash bash
export MESHAGENT_API_KEY="<your-api-key>"
export MESHAGENT_PROJECT_ID="<your-project-id>" # from meshagent project list
export ROOM_NAME="quickstart"
export EMAIL_ADDRESS="<your_email>@mail.meshagent.com"
export EMAIL_QUEUE="<your_queue_name>"
```

<CodeGroup>
    <ProvisionMailbox />
</CodeGroup>

```bash bash
python provision_mailbox.py
```

### Step 3: Run the agent locally
Make sure the queue and email address are set, then run the service:

```bash
export EMAIL_ADDRESS="support@mail.meshagent.com"
export EMAIL_QUEUE="support"
meshagent service run "main.py" --room=quickstart
```

### Step 4: Email the agent
Send an email to the mailbox and verify the `.emails/` folder and logs in MeshAgent Studio.

### Step 5: Package and deploy the agent
To deploy your SDK MailWorker permanently, you need:
1. A `meshagent.yaml` defining the service
2. A Docker image with your code

Create a Dockerfile, build and push your image, then deploy with `meshagent service create --file meshagent.yaml --room quickstart` or from MeshAgent Studio. See [Services and Room Containers](../../services_room_containers/overview) for packaging and deployment workflows.

## How MailWorker Works
### Constructor Parameters
`MailWorker` accepts everything from `Worker` (`name`, `title`, `description`, `queue`, `llm_adapter`, `tool_adapter`, `toolkits`, `rules`, `requires`) and adds email-specific configuration:

| Parameter            | Type                          | Description                                                                                                         |
| -------------------- | ----------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| `name`               | `str`                         | Unique identifier for the agent within the room.                                                                    |
| `title`              | `str \| None`                 | Display name shown in UX. Defaults to `name`.                                                                       |
| `description`        | `str \| None`                 | Optional short description.                                                                                         |
| `queue`              | `str`                         | Queue to listen on. Defaults to `"email"`.                                                                          |
| `llm_adapter`        | `LLMAdapter`                  | Required LLM adapter (for example `OpenAIResponsesAdapter`).                                                        |
| `tool_adapter`       | `ToolResponseAdapter \| None` | Optional adapter for translating tool outputs into LLM context messages.                                            |
| `toolkits`           | `list[Toolkit] \| None`       | Toolkits always available to this worker beyond what `requires` installs. Defaults to `[]`.                        |
| `rules`              | `list[str] \| None`           | System rules applied to each email thread; defaults to plain text or Markdown output.                               |
| `requires`           | `list[Requirement] \| None`   | Schemas/toolkits to install before processing. `MailWorker` always adds the `emails` table automatically.           |
| `email_address`      | `str`                         | The address used as the "From" field for outgoing replies.                                                          |
| `domain`             | `str`                         | Domain for routing/SMTP defaults. Defaults to `MESHAGENT_MAIL_DOMAIN` or `"mail.meshagent.com"`.                    |
| `smtp`               | `SmtpConfiguration \| None`   | SMTP settings. Defaults to `SMTP_USERNAME`, `SMTP_PASSWORD`, `SMTP_PORT`, `SMTP_HOSTNAME` if not provided.          |
| `toolkit_name`       | `str \| None`                 | Exposes a named toolkit that can start new email threads (`new_email_thread`).                                      |
| `whitelist`          | `list[str] \| None`           | Optional allowlist of sender emails. Messages from other senders are ignored.                                       |
| `reply_all`          | `bool`                        | Reply-all when responding to emails. Defaults to `False`.                                                           |
| `enable_attachments` | `bool`                        | Allow downloading and processing attachments, and allow attaching room files to replies. Defaults to `True`.       |
| `skill_dirs`         | `list[str] \| None`           | Directories containing agent skills; added to the rules so the model can discover and use them.                    |

### Lifecycle Overview
`MailWorker` inherits the lifecycle from `Worker` and adds mail-specific setup:
- `await start(room)`: connects to the room, installs requirements, starts the queue loop, and (if configured) starts the mail toolkit.
- `await stop()`: stops the toolkit (if any), ends the queue loop, and disconnects cleanly.

### Processing Flow
1. Wait for work by long-polling the email queue.
2. Decode the base64 `.eml`, parse headers/body/attachments, and persist data under `.emails/...` plus the `emails` table.
3. Filter out messages not addressed to the agent, bounces, auto-replies, or non-whitelisted senders.
4. Rebuild thread context by walking the `In-Reply-To` chain.
5. Resolve toolkits (`requires` + local toolkits) and optionally add the attachments toolkit.
6. Generate a reply with the LLM and send it via SMTP; persist the reply and any attachments.

### Key Behaviors and Hooks
- **Mailbox filtering:** `should_reply()` rejects bounces/auto-replies and enforces the optional whitelist.
- **Thread reconstruction:** `load_thread()` and `append_message_context()` rebuild prior messages into the LLM context.
- **Attachment handling:** incoming attachments are stored under `.emails/.../attachments`; when enabled, the agent can attach room files to replies.
- **Reply-all control:** `reply_all` controls whether replies include other thread recipients.
- **Mail tools exposure:** `toolkit_name` registers a `new_email_thread` tool so other agents can start email threads.
- **Skills integration:** `skill_dirs` append skill descriptions to rules for tool execution guidance.

### Key Methods
| Method                                                         | Description                                                                                 |
| -------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| `async def process_message(chat_context, message, toolkits)`   | Core email handler: stores email, builds thread, calls the LLM, and sends the reply.        |
| `async def append_message_context(message, chat_context, thread)` | Loads the email thread into the chat context.                                                |
| `async def send_reply_message(message, reply, attachments)`    | Composes and sends the SMTP reply and persists the message.                                  |
| `async def start_thread(to_address, subject, body, attachments)` | Starts a new outbound email thread (used by the mail toolkit).                               |
| `async def get_thread_toolkits(thread_context)`                | Resolves required toolkits for the current email thread.                                     |
| `async def should_reply(message)`                              | Filters out non-addressed mail, bounces, auto-replies, and non-whitelisted senders.          |

## Next Steps
Explore and understand other agents in MeshAgent:
- [Worker](./worker): Understand how queue based agents work
- [TaskRunner](./taskrunner): Learn how to run agents in the background or wrap existing agents from other frameworks
- [ChatBot](./chatbot): Create a conversational text/chat based agent
- [VoiceBot](./voicebot): Create a conversational speech/voice based agent

Learn how to deploy and run agents across rooms in a project or in specific rooms:
- [Services and Room Containers](../../services_room_containers/overview): Understand agent deployment patterns
