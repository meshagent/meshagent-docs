---
title: Introduction to Services
---

MeshAgent lets you add custom functionality to rooms by running your own code alongside room participants. Whether you want to build AI-agents, domain-specific tools, process data, or connect to external systems, services make it possible.

You can deploy services in two ways: as **project-wide services** that are automatically available in every room, or as **room-specific containers** that users can deploy on-demand with custom configurations. See [Deployment Options](./deployment_options) to understand which approach fits your use case.

## What are Services? 

A service is any running program that MeshAgent can call into a room. It could be running on your laptop during development, on a server you manage, or inside a MeshAgent room.

Services can be:
- **MeshAgent native**: Built using our ``ServiceHost`` and APIs for deep integration with rooms
- **Generic programs**: Any existing web service that can respond to HTTP calls

This flexibility means you can bring virtually any functionality into a MeshAgent room.

## Why use Services? 
**Extend Room Capabilities**: Add custom functionality to the room - from specialized AI agents to domain-specific tools and external system integrations.

**Flexible Deployment**: Start with local development on your machine, then deploy to production without changing your core logic. Scale from prototype to enterprise-ready automatically.

**Enterprise-Ready Infrastructure**: Deployed services get automatic scaling tied to room activity, containerized isolation for secure execution, seamless access to room context and storage, and automatic lifecycle management.

**Powerful Technical Features**:
- **Custom Code Deployment**: Run arbitrary container images (e.g. agents built with OpenAI Agent SDK, Pydantic Agents, CrewAI, Semantic Kernel).
- **Runtime Configuration**: Inject secrets and environment variables for API keys, database credentials, or feature flags.
- **Localhost Networking**: Expose one or more ports to enable inter-service communication.
- **Optional Storage Mounts**: Grant services direct read/write access to a room’s persistent storage.
- **Integrated Tool Exposure**: MeshAgent automatically converts services using the MCP SSE protocol into room-native tools available to participants.
- **Health & Readiness Probes**: Define liveness checks to prevent participants from connecting until all services are operational.

Services behave similarly to serverless functions—automatically starting and stopping with room sessions—but remain co-located within the room environment for low latency and deep integration.

## Service Lifecycle

1. **Session Start**: Upon the first participant or agent connecting, MeshAgent initializes the room and starts all configured services simultaneously.

2. **Active Session**: Services remain running as long as there is at least one active connection. They can process data, communicate via the room API, and interact with storage.

3. **Session End**: When the last participant disconnects, MeshAgent gracefully shuts down services, freeing resources until the next session.

## Communication & Security

- **Isolated Containers**  
  Each service runs in its own sandbox, ensuring that secrets and environment variables are scoped per service. One service cannot read another’s configuration.

- **Room API Integration**  
  Services interact with the room through the MeshAgent Room API, enabling messaging, event subscriptions, and storage operations.

- **Low-Latency Networking**  
  Co-location within the room environment and localhost networking dramatically reduce communication delays compared to external serverless functions.

## Real-World Use Cases

1. **AI Agent Orchestration**: Deploy a semantic-kernel-based agent that processes user queries and writes responses directly to the room chat.
2. **Voice Agents**: Run a long-lived voice transcription and synthesis service—difficult to host in traditional serverless—allowing real-time audio interaction in the room.
3. **Custom Business Logic**: Spin up an MCP server as a service to handle domain-specific workflows (e.g., data validation, report generation), automatically surfaced as tools for room participants.
4. **Data Processing Pipelines**: Mount room storage into a service that ingests, transforms, and outputs data files, with progress updates sent back via the room API.
5. **Secure Integrations**: Use environment-injected secrets to connect to third-party APIs (e.g., CRM systems, analytics platforms) entirely within the room sandbox.

## Next Steps
- [Deployment Options](./deployment_options): Decide how to make your service available to users either at the project-level or room level. 
- [Local Development](./local_development): Learn how to build and test MeshAgent services on your machine using ServiceHost
- [Service Configuration](./service_configuration): Learn how to configure your MeshAgent service for project-level deployment.
- [Service Deployment](./service_deployment): Deploy your service to your MeshAgent project making it available to all the rooms in your project.

## REMOVE BELOW LATER ONCE REPLACED 
## Configuration Options

Services can be customized via the MeshAgent Studio’s **Services** tab:

- **Image Selection**  
  Choose from public or private container registries. For private images, configure a pull secret to grant access.

- **Environment Variables & Secrets**  
  - Define key/value environment variables  
  - Reference secure secrets (e.g., API tokens, database URIs)

- **Port Definitions**  
  Expose ports for HTTP servers, gRPC endpoints, or custom protocols; accessible to other services and room clients over localhost.

- **Storage Mount**  
  Optionally mount the room’s storage volume into the service container, enabling direct file access.

- **Health Checks**  
  - **Liveness**: periodically verify the service process is alive  
  - **Readiness**: ensure availability before allowing room connections


With MeshAgent services, you can effortlessly extend room capabilities with robust, secure, and low-latency processes—all managed through a simple UI without worrying about infrastructure.