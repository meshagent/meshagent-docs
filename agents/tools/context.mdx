---
title: "How Tools and Toolkits Work"
---

MeshAgent Tools aren’t just for agents — people can use them too. This guide explains how tools, toolkits, and rooms fit together so that both humans and AI agents can safely discover, call, and share capabilities. You’ll see how tools are defined, validated, executed, and connected to MeshAgent rooms. 

## Mental Model (how tool concepts fit together)
- ``Tool`` = one discrete action an agent (or human participant) can take (e.g., WriteDocument, PresentForm).
- ``Toolkit`` = a named bundle of tools plus optional rules (e.g., DocumentWritingToolkit with tools to ``read_document`` and ``summarize_document`` along with instructions for how to use these tools).
- ``ToolContext`` = everything a tool needs when it runs (the active room, who called, optional “on behalf of”, extra caller context).
- ``RemoteToolkit`` = a runtime wrapper that registers your toolkit with the room, listens for tool calls, validates inputs, runs the tool, and returns a structured Response.

## `ToolContext`
MeshAgent tools are passed a ``ToolContext`` when the tool is executed. This object carries a variety of information that helps the tool operate:

### Constructor Parameters
| Property | Description |
|---|---|
|**room** | a room client that can be used to interact with the room or other participants in the room|
|**caller** | the participant who called the tool|
|**on_behalf_of** | if the tool was called by an agent that was acting on behalf of a user, the participant who invoked the agent|
|**caller_context** | an optional dictionary of caller specific context data, this can be used to provide custom context data to the tool. For instance, this can be used for allowing agent based tools to receive the current chat context for implementing patterns such as handoffs.|

## `Tool`

A ``Tool`` defines an action that an agent or person can perform. The tool declares what it expects in the ``input_schema`` and what actions to perform in its ``execute()`` method.

### Constructor Parameters
| Parameter           | Type                        | Default | Description                                                                                                  |
| ------------------ | --------------------------- | ------: | ------------------------------------------------------------------------------------------------------------ |
| `name`             | `str`                       |       — | Unique tool name within a toolkit.                                                                           |
| `input_schema`     | `dict`                      |       — | **JSON Schema** for the tool’s arguments. Enforced at call time.                                             |
| `title`            | `Optional[str]`             |  `name` | Human-readable display name.                                                                                 |
| `description`      | `Optional[str]`             |    `""` | Short description of the tool.                                                                               |
| `rules`            | `Optional[list[str]]`       |  `None` | Behavioral guidance/prompts for LLMs.                                                                        |
| `thumbnail_url`    | `Optional[str]`             |  `None` | Icon/thumbnail shown in UIs.                                                                                 |
| `defs`             | `Optional[dict[str, dict]]` |  `None` | Reusable JSON Schema definitions. Merged into the schema via `$defs`. Use to avoid repeating complex shapes. |
| `supports_context` | `Optional[bool]`            | `False` | Indicates the tool can use `caller_context` when provided.                                                   |

### Methods

A tool must have an ``execute()`` method where its logic is implemented.

```bash Python
async def execute(self, context:ToolContext, **kwargs) -> Response:
    ...
```

## `RequestTool`
The `RequestTool` is designed for when you need the raw `Request` as input instead of JSON-validated arguments. This is useful for tools that perform file uploads or require binary payloads. 

### Constructor Parameters
| Parameter           | Type                  | Default | Description                                                |
| ------------------ | --------------------- | ------: | ---------------------------------------------------------- |
| `name`             | `str`                 |       — | Unique tool name within a toolkit.                         |
| `title`            | `Optional[str]`       |  `name` | Human-readable display name.                               |
| `description`      | `Optional[str]`       |    `""` | Short description of the tool.                             |
| `rules`            | `Optional[list[str]]` |  `None` | Behavioral guidance/prompts for LLMs.                      |
| `thumbnail_url`    | `Optional[str]`       |  `None` | Icon/thumbnail shown in UIs.                               |
| `supports_context` | `Optional[bool]`      | `False` | Indicates the tool can use `caller_context` when provided. |

### Methods
These tools must have an ``execute()`` method where its logic is implemented
```bash Python
async def execute(self, *, context: ToolContext, request: Request) -> Response: 
    ...
```

## ``Toolkit``
A toolkit is used to group related tools together and ... (what it does)

### Constructor Parameters
| Parameter        | Type             |       Default | Description                                                              |
| --------------- | ---------------- | ------------: | ------------------------------------------------------------------------ |
| `name`          | `str`            |             — | Toolkit identifier used for discovery/invocation (`<toolkit>/<tool>`).   |
| `tools`         | `list[BaseTool]` |             — | The tools this toolkit exposes (`Tool` and/or `RequestTool`).            |
| `rules`         | `list[str]`      | `list[str]()` | Optional global guidance/prompts that apply to all tools in the toolkit. |
| `title`         | `Optional[str]`  |        `name` | Human-readable toolkit name.                                             |
| `description`   | `Optional[str]`  |          `""` | Description shown in UIs / discovery.                                    |
| `thumbnail_url` | `Optional[str]`  |        `None` | Icon/thumbnail for the toolkit.                                          |

### Methods
- ``get_tool()``: returns a tool or raises a ``RoomException`` if the tool is missing from the room 
- ``execute()``: 
    - If the tool is a ``RequestTool`` is builds a ``Request`` from the provided arguments then invokes the tool and ensures a valid return type.
    - If the tool is a ``Tool``, it validates the arguments using the ``input_schema`` (and ``defs``) then invokes the tool and ensures a valid return type

## Local vs Remote Toolkits


## RemoteToolkit and Toolkit Factories 


## Tool Execution Lifecycle 
(is this needed? )

## Tool Access and Permissions
(who can use tools and public vs private)

## Next Steps
- [Tools Quickstart](./quickstart): Try creating and running your first tool. 
- [Dynamic UI Tools](./dynamic_ui_tools): Understand what dynamic UI tools are, why they matter, and how to build them. 