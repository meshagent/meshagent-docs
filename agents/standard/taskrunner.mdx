---
title: "TaskRunner"
---

A TaskRunner is the bridge that makes any **existing AI Agent built in your framework of choice work seamlessly with MeshAgent**. It is a base agent class designed with one core principle: **bring your own logic**. 

## Why TaskRunner Exists

Many developers already have agents built with their preferred frameworksâ€”whether that's Pydantic AI, LangChain, CrewAI, or custom implementations. TaskRunner eliminates the need to rewrite these agents. Instead, you simply wrap your existing agent with a TaskRunner and can instantly share, deploy, scale, and manage your agents in a cohesive way. 

## Core Components

A TaskRunner defines: 
- **Input Schema**: JSON schema describing what arguments your agent accepts
- **Output Schema**: JSON schema describing what your agent returns
- **Ask Method**: Your custom logic that processes inputs and returns results

A TaskRunner joins a MeshAgent Room and can be discovered and invoked from the [MeshAgent Studio](https://studio.meshagent.com) using the "Run Task..." menu option or using the ```room.agents.ask``` method on the API.

## Example: Integrating a Pydantic AI Agent

This example shows how to wrap an existing Pydantic AI translation agent with a MeshAgent TaskRunner. We extend the base TaskRunner class to create our TranslationTaskRunner with a defined input schema, output schema, and ask method. 

Copy this code into a file called ``translator.py``. You will need to create and export an ``ANTHROPIC_API_KEY`` first for this to run.

```python Python
import os
import json
import asyncio
import logging
from datetime import date, datetime
from meshagent.otel import otel_config
from meshagent.api.services import ServiceHost
from meshagent.agents import TaskRunner
from meshagent.api.messaging import TextResponse, JsonResponse

from pydantic_ai import Agent
from pydantic import BaseModel, Field, ConfigDict
from pydantic_ai.models.anthropic import AnthropicModel
from pydantic_ai.providers.anthropic import AnthropicProvider

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

otel_config(service_name="my-service")

service = ServiceHost(
    port=int(os.getenv("MESHAGENT_PORT","7777"))
)

# Define Inputs, Outputs, and Pydantic AI Agent for Translation
class TranslationInput(BaseModel):
    text:str = Field(..., description="Text to translate")

    model_config = ConfigDict(extra='forbid')

class TranslationResult(BaseModel):
    french_translation:str
    spanish_translation:str

    model_config = ConfigDict(extra='forbid')

translation_agent = Agent(
    model=AnthropicModel('claude-4-sonnet-20250514', provider=AnthropicProvider()), #pass API key from env variables
    deps_type=None,
    instructions=f"""
        # Role Background
        You are responsible for translating recent news announcements into other languages. You are exposed to a variety of topics beyond your knowledge cutoff date. The current date is: {date.today().strftime("%B %d, %Y")}

        # Task
        Provide two translations, one in French and one in Spanish.     
    """,
    output_type=TranslationResult
)

# Utility function
async def save_to_storage(room, path: str, data: bytes):
        handle = await room.storage.open(path=path, overwrite=True)
        await room.storage.write(handle=handle, data=data)
        await room.storage.close(handle=handle)

# Use Pydantic AI agent in a MeshAgent Room
@service.path("/translator")
class TranslationTaskRunner(TaskRunner):
    def __init__(self):
        super().__init__(
            name="Translator",
            description="An agent that translates text to French and Spanish",
            input_schema=TranslationInput.model_json_schema(),
            output_schema=TranslationResult.model_json_schema()
        )

    async def ask(self, *, context, arguments):
        room=context.room

        inputs = TranslationInput(**arguments)
        log.info(f"Translating Text: {inputs.text}")

        translations = await translation_agent.run(inputs.text)
        log.info(f"Translation Result: {translations.output}")

        # save results to room storage
        log.info(f"Translation completed, writing raw results to Room storage.")
        
        await save_to_storage(
            room=room,
            path=f"translations/{room.room_name}-translation-{datetime.now():%Y%m%dT%H%M%S}.json",
            data=json.dumps({"input_text": inputs.text, "translations": translations.output.model_dump()}, indent=2, ensure_ascii=False).encode("utf-8")
        )

        return translations.output.model_dump()

print(f"running on port {service.port}")
asyncio.run(service.run())

```
### Running the TaskRunner

**In your terminal**

Start your service locally. Be sure you are in an activated virtual environment where meshagent and pydantic_ai are installed: 

```bash bash
python translator.py
```

Next use the MeshAgent CLI to authenticate and call your agent into a Room:
```bash bash
meshagent setup # this will authenticate you 
meshagent call agent --url=http://localhost:7777/translator --room=translate --participant-name=translator
```

**In the Studio**
1. Go to [studio.meshagent.com](https://studio.meshagent.com) 
2. Enter the room, ``translate``
3. Click menu --> "Run Task"
4. Select "Translator" from the agent dropdown 
5. Enter the text to translate
6. Results appear and are saved to room storage under the "translations" folder 

**Invoking the TaskRunner Programmatically**

Instead of invoking the agent through the Studio, you can also run the agent through code like this: 

```python Python
import asyncio
import json
from typing import Dict, Any
from meshagent.api import RoomClient, websocket_protocol

async def call_agent(
    room_name: str, 
    agent_name: str, 
    arguments: Dict[str, Any], 
    participant_name: str = "api_client"
) -> Dict[str, Any]:
    """Call a MeshAgent agent with the given arguments."""
    async with RoomClient(
        protocol=websocket_protocol(
            participant_name=participant_name, 
            room_name=room_name
        )
    ) as room:
        result = await room.agents.ask(
            agent=agent_name, 
            arguments=arguments
        )
        # Extract JSON data from JsonBody response
        return result.json if hasattr(result, 'json') else result

async def main():
    # Call your translator
    result = await call_agent(
        room_name="translate",
        agent_name="Translator",
        arguments={"text": "Hello, how are you today?"}
    )
    
    print("Translation result:")
    print(json.dumps(result, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    asyncio.run(main())
```

## Prebuilt MeshAgent TaskRunners
MeshAgent provides pre-built agents that extend the TaskRunner class with additional capabilities. These built-in agents are automatically available in every MeshAgent room as ``meshagent.planner`` and ``meshagent.schema_planner``.

### PlanningResponder
A TaskRunner that adds tool usage, iterative reasoning, and structured planning. It takes in a prompt, an optional set of custom tools, and returns a text response.

### DynamicPlanningResponder 
A TaskRunner that takes in a prompt an optional set of custom tools, and returns a structured response.

You can customize the PlanningResponder with the following constructor parameters:

**requires:** a list of requirements for the agent. You can use RequiredSchema, RequiredToolkit to use toolkits and schemas that have been registered with the room with this agent.

**input_prompt:** Whether the planner should accept a prompt as input, if true, the input should be in the format ```{ "prompt" : "text" }```.

**output_schema:** a JSON schema that responses must conform to.

**llm_adapter:** a LLM adapter to use to integrate with a LLM. We recommend using the OpenAIResponsesAdapter from ```meshagent-openai```.

**toolkits:** used to specify local toolkits for the agent. While it's generally recommended to register toolkits with the room so any agent or user can use them, sometimes you need each agent to have it's own instance of a toolkit, for instance with synchorized document authoring.

**rules:** a set of rules that the task runner should use while executing. Rules are used to guide the behavior of the agent with system or developer prompts (optional).

**max_iterations:** the maximum number of iterations of the planning loop (optional).

**tool_adapter:** a custom tool adapter to use to transform tool responses into context messages (optional).

**supports_tools** Whether the agent should support passing a custom set of tools at runtime (optional)

Two preconfigured task runners are available by default in MeshAgent rooms. These are available as ```meshagent.planner``` and ```meshagent.schema_planner``` via the ```room.agents.ask``` api.
You can try them out in the Studio by selecting "Run Task..." from the menu. These built in agents can be useful helpers in your own apps. For example, when you invoke an agent inside the
MeshAgent Studio, the PlanningResponder is used to generate user interface on the fly and gather the required JSON data to pass as input when invoking an agent. Extending the base TaskRunner 
and providing a custom set of rules and tools is a great way to get a simple agent up and running quickly.

TaskRunners can also be surfaced in toolkits and used as tools that can be used by other agents using the RunTaskTool. Exposing agents as tools and then giving those tools to a ChatBot is a great way to get started building multi agent systems. 

The base TaskRunner requires JSON schemas to be provided to describe the input and output format. 