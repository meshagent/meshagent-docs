---
title: "Overview"
---

# MeshAgent

[MeshAgent](https://www.meshagent.com) is the **agent-native application platform** for building, deploying, and operating **multiplayer AI applications**—where **humans, agents, and tools** work together in real time over shared context.

MeshAgent is designed for the world where AI isn’t a chatbot inside your product, but a **digital team member** that:
- executes work continuously,
- coordinates with other agents and people,
- uses tools and services at “agent speed,” and
- must be governed, observed, and cost-controlled like production software.

MeshAgent gives teams a single place to **build, deploy, and operate** these systems collaboratively, securely, and at any scale—without stitching together databases, storage, auth, queues, tracing, and runtime infrastructure by hand.

Any conversational agents you deploy with MeshAgent can be used immediately in [Powerboards](https://www.powerboards.com/), an open-source AI-native app built entirely on MeshAgent. Use it to share agents today, or fork it into your own MeshAgent-powered application. See [Share Agents in Powerboards](../services_room_containers/share_agents_in_powerboards) for deployment details.

---

## Why MeshAgent in 30 seconds

MeshAgent is built for the “agentic” era where the hard problems shift from prompting to **coordination, context, governance, and reliability**:

- **A platform, not a framework**: Build complete applications—not just agent logic. MeshAgent provides the runtime, control plane, and managed infrastructure needed for production.
- **Multiplayer by design**: Real AI systems are multi-participant: multiple humans + multiple agents + tools, collaborating in shared context with handoffs and parallel work.
- **Context is infrastructure**: Shared state (documents, files, database, messages) must be live, synchronized, and permissioned—not rebuilt per prompt.
- **Operate with confidence**: Built-in tracing, streaming logs, cost attribution, and granular permissions let you run agent systems safely in production.

---

## The core idea: Rooms are the coordination substrate

[Rooms](./key_concepts) are secure, on-demand workspaces that provision when the first participant joins and retire automatically when the last leaves.

Inside a Room, MeshAgent provides the primitives you need to run real agent applications:

### Participants (humans + agents + tools)
- Register **[agents](../agents/standard/intro)** (chat, voice, worker/task, background) as first-class participants
- Register **[tools](../agents/tools/intro)** (built-in, custom, MCP) and invoke them programmatically
- Invite teammates to collaborate live from [MeshAgent Studio](./meshagent_studio), Powerboards, or your own application

### Built-in platform services
Rooms include [built-in APIs](../room_api/overview) that remove infrastructure glue work:

- **[Agents API](../room_api/agents)** — invoke agents and tools as services
- **[Containers API](../room_api/containers)** — ad-hoc code execution on demand
- **[Database API](../room_api/database)** — store, query, and power semantic search / vector embedding / RAG workloads
- **[Developer API](../room_api/developer)** — send structured logs to the developer console and subscribe to events
- **[Messaging API](../room_api/messaging)** — real-time communication between humans and agents
- **[Queues API](../room_api/queue)** — async task distribution and coordination for multi-agent workloads
- **[Secrets API](../room_api/secrets)** — secure credential and OAuth token management
- **[Storage API](../room_api/storage)** — upload, download, and manage files
- **[Sync API](../room_api/sync)** — real-time collaborative document editing with [MeshDocuments](../documents/quickstart)

### Governance and observability (built-in, not bolted on)
- Granular permissions for every participant and service
- Streaming logs and traces so you can observe every message, tool call, latency, and cost
- Cost attribution across agents, Rooms, providers, and projects

---

## Built for “agent-speed” workloads

Agent applications behave differently than human-driven apps:
- Work arrives in bursts (fan-out tool calls, parallel agents, retries)
- Latency and cold starts matter more (agent loops magnify delays)
- Reliability requires coordination (queues, permissions, state, backpressure)

MeshAgent is built to eliminate the typical “agent infrastructure” tax by giving you:
- a production runtime for agents and services,
- a collaborative execution boundary (Rooms),
- and platform primitives (database/storage/queues/secrets/containers) that are already wired together.

---

## MeshDocuments: shared state beyond chat logs

Most “agents” collapse into brittle prompt chains because the only shared state is chat history.

**[MeshDocuments](../documents/quickstart)** provides an AI-native, synchronized context plane:
- **Live shared documents** agents and humans can read/write together
- **Structured, durable state** that reduces prompt fragility
- A foundation for rich collaborative UIs and agent-driven editing
- **MeshWidgets** for cross-platform interactive experiences with scripting and agent-assisted development

---

## Powerful agents, batteries included

MeshAgent includes production-ready agent templates that handle real-world complexity:

- Standard agents: **[workers](../agents/standard/worker), [chatbots](../agents/standard/chatbot), [voicebots](../agents/standard/voicebot), [mailworkers](../agents/standard/mailworker)**
- Advanced capabilities: computer use, media generation, secure local shell access, coding workflows
- Built-in meetings + transcription so agents can reason and act during live conversations
- Multimodal pipelines (image/video/audio models) for generative media and rich authoring experiences
- Mailbots + document intelligence: process attachments, categorize and query documents, generate insights, and enrich context with research tools

---

## Deploy services without rewrites

Moving from prototype to production often fails because deployment, permissions, and service wiring are an afterthought.

[MeshAgent Services](../services_room_containers/overview) make it easy to package and run:
- agents,
- tools,
- connectors,
- and supporting services.

Key workflows:
- **Test locally first** — use [`ServiceHost`](../services_room_containers/local_development) and the MeshAgent CLI to run a service in a Room locally
- **Built-in integrations** — native support for MCP Servers and OpenAI Connectors, plus prebuilt toolkits
- **Flexible deployment** — deploy as a **project service** (available to all Rooms) or a **room service** (scoped to specific Rooms)

---

## Enterprise-grade governance

Production agent systems require fine-grained controls defining who can join, what can run, and what data can be accessed.

MeshAgent includes governance at every level:
- **Room access control** — define who can join which Rooms
- **Participant permissions (API Scopes)** — lock down what humans/agents can do (e.g., read storage but not write)
- **Service permissions** — control what deployed services can access (e.g., can use storage but not containers)
- **Project vs. Room scoping** — expose services broadly or only within specific Rooms

---

## Enterprise-grade observability and cost management

Debugging agent systems means tracking prompts, tool calls, latency, errors, and cost across distributed components.

MeshAgent provides:
- streaming logs and OpenTelemetry traces (no middleware required). See [Observability](../observability/intro).
- automatic recording of prompts, tool calls, and results
- latency histograms + real-time error tracking
- per-agent cost attribution and billing breakdowns
- an in-room LLM proxy that secures API keys and provides automatic cost attribution and controls

---

## Powerboards: an open-source distribution and collaboration surface

[Powerboards](https://www.powerboards.com/) is an open-source AI-native application built entirely on MeshAgent. See [Share Agents in Powerboards](../services_room_containers/share_agents_in_powerboards).

Use Powerboards to:
- share your MeshAgent-deployed conversational agents immediately
- collaborate in real time with humans + agents over shared context
- adopt it as-is, or fork it into your own MeshAgent-powered product

Powerboards demonstrates the “multiplayer AI” model end-to-end: Rooms, shared context, governed access, and real-time collaboration—without requiring every team to build the app surface from scratch.

---

## Core components

| Component | What it does | Typical use |
|-----------|--------------|-------------|
| **[MeshAgent SDKs](../reference/sdk_reference)** | Language clients ([Python](https://pypi.org/project/meshagent/), [TypeScript/JavaScript](https://www.npmjs.com/package/@meshagent/meshagent), [Dart](https://pub.dev/documentation/meshagent/latest/), [.NET](https://www.nuget.org/packages/Meshagent.Api)) that wrap Rooms, agents, messaging, storage, queue APIs and more. | Build agent apps and call platform services with a few lines of code. |
| **[MeshAgent Studio](./meshagent_studio)** | [Browser workspace](https://studio.meshagent.com) + CLI for prototyping, testing tools, evaluating agents, and inviting teammates into live Rooms. | Multiplayer development: iterate fast with stakeholders and teammates in the same live Room. |
| **MeshAgent Server** | Managed backend that hosts agents, provisions secure Rooms, scales infrastructure, and exposes usage & billing dashboards. | Run agent applications in production without maintaining the underlying infrastructure. |
| **Powerboards** | Open-source AI-native app built on MeshAgent for sharing and collaborating with deployed agents. | Use as-is for distribution, or fork into your own MeshAgent-powered application surface. |

---

## Works with your stack

MeshAgent is designed for real teams and real stacks:
- Official SDKs for Python, JavaScript/TypeScript, Dart/Flutter, and .NET
- UI starters when you want them (React/Tailwind web widget and Flutter chat/voice widgets), or bring your own components
- Cross-language collaboration: TypeScript UI + Python agent + .NET/Go service can work together in one Room
- Bring your existing agents: run agents built with Pydantic AI, CrewAI, etc. alongside MeshAgent agents

| Language | What you get today | Best for |
| --- | --- | --- |
| **[Python](https://pypi.org/project/meshagent/)** | Full agents (ChatBot, VoiceBot, Worker, TaskRunner), Room API, REST helpers | Authoring and hosting production agents |
| **[TypeScript / JavaScript](https://www.npmjs.com/package/@meshagent/meshagent)** | Room client (browser/Node), document sync, starter React/Tailwind chat widget | Web apps and embeddable chat |
| **[Dart / Flutter](https://pub.dev/packages/meshagent)** | Room client, Flutter chat + voice caller widgets, project/secret/service REST helpers | Mobile apps and Flutter UIs |
| **[.NET](https://www.nuget.org/packages/Meshagent.Api)** | Room client + REST/project administration helpers | Server integrations and services |

See the full breakdown in [Language SDKs](../reference/sdk_reference).

---

## Next steps

- [**Getting Started**](./get_started): Install MeshAgent, connect to your first Room, and run your first agent.
- [**Key Concepts**](./key_concepts): Learn how Rooms, Agents, Tools, and Services fit together.
