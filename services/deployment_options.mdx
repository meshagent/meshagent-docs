---
title: Deployment Options
---

MeshAgent provides two deployment patterns for services, each designed for different use cases and operational needs. The key difference is availability: project-wide services are always available to all rooms inside a project, while room-specific containers are dynamic and deployed on-demand when needed.

## Project-Wide Services
**Static, always-available functionality across all rooms in your project**

Services are deployed once by project admins and automatically available in every room. Perfect for:
- Core agents that all users should have at all times (like a "MeshAgent Support Agent")
- Functionality that should always be available (like a "Transcription Agent" ready whenever someone speaks)
- Background services that need to run continuously (like activity monitors)
- Administrative services that manage room behavior

**Example**: Deploy a transcription agent as a project-wide service so it's always ready to transcribe speech in any room. Then users can deploy a transcript analysis container when they want to process the day's transcriptions with custom parameters or send results to their preferred system.

## Room-Specific Containers
**Dynamic, on-demand functionality that users can deploy when needed**

Containers are deployed by individual users into specific rooms with custom configuration. Ideal for:
- Experimental or prototype agents
- Personalized tools with custom settings (like a chatbot with user-defined system prompts)
- Specialized workflows for specific projects
- Ad-hoc processes that analyze or transform data

**Example**: Create a customizable chatbot container that users can deploy with their own system prompts - one user might configure it to always respond in Spanish, while another sets it up as a code reviewer. Create a LinkedIn agent that drafts and posts content to LinkedIn, which users can optionally add to their room. 

## Key Differences

| Aspect | Project-Wide Services | Room-Specific Containers |
|--------|---------------------|--------------------------|
| **Scope** | All rooms in project | Single room |
| **Deployed by** | Project admins | Individual users |
| **Availability** | Automatic on room start | On-demand deployment |
| **Configuration** | Fixed at deployment time | Customizable per deployment |
| **Use case** | Core, shared functionality | Personalized, experimental tools |

## Choosing the Right Pattern
**Choose Project-Wide Services when**:
- The functionality should be available to all users
- Configuration is standardized across the organization
- You need consistent behavior across all rooms
- It's core infrastructure that admins should control

**Choose Room-Specific Containers when**:
- Users need to customize configuration (prompts, parameters, etc.)
- The functionality is experimental or specialized
- Different users have different requirements
- You want to let users opt-in to using the functionality

## Development to Deployment Workflow
Regardless of which deployment pattern you choose, the development process is the same:
1. **Local Development**: Start by building services on your machine using ``ServiceHost``, MeshAgent's Python SDK component that turns your code into HTTP endpoints. Test and iterate quickly by calling services into rooms using the MeshAgent CLI.
2. **Configuration**: Define how your code should run in a meshagent.yaml file (ServiceSpec for project-wide services, and ServiceTemplate for containers) and create a Dockerfile. 
3. **Deployment**: Deploy project-wide services using the MeshAgent CLI or MeshAgent Studio UI. Run containers in a  specific room by providing either a GitHub repository containing meshagent.yaml and Dockerfile, or a pre-built Docker image from a registry.

Your core service logic stays the same whether running locally or deployed to production - MeshAgent handles the infrastructure differences for you.

## Next Steps
- [Local Development](./local_development): Learn how to build and test MeshAgent services locally
