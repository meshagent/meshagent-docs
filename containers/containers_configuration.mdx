---
title: Containers Configuration
---

Room-specific containers are configured using the ``ContainerSpec`` which defines how your service should run within a room. Unlike project-wide services, containers are deployed on-demand and can be customized per deployment. 

For each container you will need a the applicable source code, a Dockerfile, and a meshagent.yaml which defines the configuration options using the ``ContainerSpec``. 

## When to Use ContainerSpec
ContainerSpec is required for all room-specific container deployments. You'll need it whether you're:

- Running your own container in a specific room
- Creating reusable container templates for your team or organization
- Allowing others to deploy your container with their own configuration
- Running ad-hoc processes at any time inside a room

## How Container Templates Work

> **Behind the Scenes**: When someone deploys your ContainerSpec template, MeshAgent converts it to a [ServiceSpec](../services/service_configuration) by substituting their provided variable values. The resulting ServiceSpec is what actually runs in the room.

This transformation allows you to create flexible templates while maintaining the same underlying runtime configuration used by project-wide services.

## ContainerSpec Structure
A ContainerSpec defines a reusable template for deploying containers, including environment variables that get filled in when the service is deployed, ports, and storage requirements. For example, if you want to allow the user to set a system prompt for the agent you could make this a configurable variable. 

A ContainerSpec contains:  
- **version**: The template version
- **kind**: The template kind (use ``ServiceTemplate``)
- **metadata**: Information about the service including a ``name`` and ``description``
- **variables**: Configurable values you can set when deploying (optional)
- **environment**: How variables become environment variables in your container (optional)
- **ports**: How MeshAgent calls your service endpoints (MeshAgent will automatically assign services to available ports)
- **command**: What command runs when your container starts (optional)
- **role**: Service role - ``agent``, ``tool``, or ``user`` (optional, will likely be set at the port endpoints level)
- **storage**: Mount room or project storage into your container (optional)

### Metadata
Metadata keep track of important information about your service like the name and description, and optionally an icon associated with the service and repository where the code for the service lives. 

```yaml yaml
metadata: 
  name: agent-service
  description: "A chat based agent without tools"
```

### Variables
Variables make your ContainerSpec reusable by allowing different values when deploying. For example, if you need to pass a system prompt or api key you could modify the variables section like this so the user can provide the api key (and keep the key hidden): 

```yaml yaml
variables:
- name: "system_prompt"
  description: "The system prompt for the chatbot"
- name: "model_name"
  description: "AI model to use"
  enum: ["gpt-4", "gpt-3.5-turbo"]
  optional: true
- name: "api_key"
  description: "External API key"
  obscure: true  # Hide value in UI
```

Variable Options:
- ``description``: Help text shown in the UI
- ``enum``: Dropdown list of allowed values
- ``optional``: Whether the variable is required
- ``obscure``: Hide the value in the UI (for sensitive data)

### Environment Variables
Map template variables to environment variables in your container. For example: 

```yaml yaml
environment:
- name: SYSTEM_PROMPT
  value: "{system_prompt}"
- name: MODEL_NAME
  value: "{model_name}"
- name: OPENAI_API_KEY
  value: "{api_key}"
```

**Variable Substitution**: Use ``{variable_name}`` syntax to substitute user-provided values into environment variables.

### Ports and Endpoints
Define how MeshAgent connects to your container based service(s):

```yaml yaml
ports:
- num: "*"  # Let MeshAgent assign an available port
  liveness: "/"  # Health check endpoint to make sure tools and agents are ready 
  endpoints:
  - path: /agent
    identity: chatbot
    type: meshagent.callable
  - path: /tool
    identity: helper-tool
    type: meshagent.callable
```

Port Options:
- ``num``: Port number or "*" for auto-assignment
- ``liveness``: Health check path
- ``endpoints``: List of endpoints this port serves

Endpoint Options:
- ``path``: URL path for this endpoint
- ``identity``: Unique name for this agent/tool
- ``type``: Protocol type (meshagent.callable, mcp.sse, http, tcp)
- ``role``: Override the service role for this endpoint (optional)

### Storage
Optionally mount storage into your container for file access. This can be done at the room or project level. Room-storage is for room-specific files and read/write by default. Project-wide shared files are read-only by default. For example: 

```yaml yaml
storage:
  room:
  - path: /data
    read_only: false
  - path: /app/shared
    subpath: "user-uploads"
    read_only: true
  project:
  - path: /app/models
    read_only: true
```

## Example

Let's create a simple chatbot that allows users to give it a system prompt when deploying. To deploy this we'll need the main.py file, a Dockerfile, and a meshagent.yaml file.

**main.py**

```python Python
import os
import asyncio
import logging
from meshagent.agents.chat import ChatBot
from meshagent.api.services import ServiceHost
from meshagent.openai import OpenAIResponsesAdapter

logging.basicConfig(level=logging.DEBUG)

system_prompt = os.getenv("SYSTEM_PROMPT")
rules = [system_prompt] if system_prompt else []

host = ServiceHost()

@host.path("/agent")
class MyChatBot(ChatBot): 
    def __init__(self):
        super().__init__(
            name="chatbot",
            rules=rules,
            llm_adapter=OpenAIResponsesAdapter(),
        )

asyncio.run(host.run())
```

**Dockerfile**

```Dockerfile Dockerfile
FROM meshagent/python-sdk-slim:latest

COPY . /src

WORKDIR /src

ENTRYPOINT [ "python3", "main.py" ]
```

**meshagent.yaml**
```yaml yaml
kind: ServiceTemplate
version: v1
metadata:
  name: chatbot
  description: "chatbot that takes a system prompt"

variables:
- name: "system_prompt"

environment:
- name: SYSTEM_PROMPT
  value: "{system_prompt}"

ports:
- num: "*"
  liveness: "/"
  endpoints:
  - path: /agent
    identity: chatbot
    type: meshagent.callable
```

Now that we have our agent code, Dockerfile, and meshagent.yaml file set up we're ready to go!

## Next Steps
- [Container Deployment](./containers_deployment): Learn how to deploy room-specific containers. 
- [Project Level Services](../services/service_deployment): Configure and deploy a project wide service. 