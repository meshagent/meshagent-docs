import MessagingSent from "/snippets/examples/python/messaging-send.py"


### Enabling Messaging

Before sending or receiving messages, you must enable messaging on your local participant’s side:

<CodeGroup>
```python Python
await room.messaging.enable()
```
```javascript JavaScript
await room.messaging.enable();
```
```typescript TypeScript
await room.messaging.enable();
```
```dart Dart
await room.messaging.enable();
```
</CodeGroup>


Optionally, you can provide a callback `on_stream_accept` if you also plan to use “streaming” messages. For basic text/binary messages, you can ignore streams.

### Sending a Message

To send a message, use:


<CodeGroup>
```python Python
await room.messaging.send_message(
    to = some_remote_participant,
    type = "my_message_type",      # Arbitrary label for your message
    message = { "key": "value" },  # Arbitrary dict to represent your payload
    attachment = b"some data"      # (optional) Byte payload
)
```
```javascript JavaScript
await room.messaging.sendMessage({
    to: someRemoteParticipant,
    type: "my_message_type",      // Arbitrary label for your message
    message: { key: "value" },    // Arbitrary object to represent your payload
    attachment: new Uint8Array()  // (optional) Byte payload
});
```
```typescript TypeScript
await room.messaging.sendMessage({
    to: someRemoteParticipant,
    type: "my_message_type",      // Arbitrary label for your message
    message: { key: "value" },    // Arbitrary object to represent your payload
    attachment: new Uint8Array()  // (optional) Byte payload
});
```
```dart Dart
await room.messaging.sendMessage(
    to: someRemoteParticipant,
    type: "my_message_type",      // Arbitrary label for your message
    message: { "key": "value" },  // Arbitrary map to represent your payload
    attachment: Uint8List(0)      // (optional) Byte payload
);
```
</CodeGroup>


Where:

- `participant` is a `Participant` (specifically a `RemoteParticipant` on the other end) to whom you are sending the message.
- `type` is a string label to help classify or route the message.
- `message` is a JSON-serializable dictionary included as part of your message.
- `attachment` is an optional bytes object for binary data.

### Receiving Messages

When you enable messaging, you can register an event handler for the `"message"` event to receive custom messages:

<CodeGroup>
```python Python
def on_message(message: RoomMessage):
    print(f"Received message from {message.from_participant_id}")
    print(f"Message type: {message.type}")
    print(f"Message content (JSON): {message.message}")
    if message.attachment:
        print(f"Binary payload: {message.attachment}")

room.messaging.on("message", on_message)
```
```javascript JavaScript
function onMessage(event) {
    const message = event.message;

    console.log(`Received message from ${message.fromParticipantId}`);
    console.log(`Message type: ${message.type}`);
    console.log(`Message content (JSON): ${message.message}`);
    if (message.attachment) {
        console.log(`Binary payload: ${message.attachment}`);
    }
}

room.messaging.on("message", onMessage);
```
```typescript TypeScript
function onMessage(event: RoomMessageEvent) {
    const message: RoomMessage = event.message;

    console.log(`Received message from ${message.fromParticipantId}`);
    console.log(`Message type: ${message.type}`);
    console.log(`Message content (JSON): ${message.message}`);
    if (message.attachment) {
        console.log(`Binary payload: ${message.attachment}`);
    }
}

room.messaging.on("message", onMessage);
```
```dart Dart
void onMessage(RoomMessageEvent event) {
    final RoomMessage message = event.message;

    print("Received message from ${message.fromParticipantId}");
    print("Message type: ${message.type}");
    print("Message content (JSON): ${message.message}");
    if (message.attachment != null) {
        print("Binary payload: ${message.attachment}");
    }
}

room.listen((RoomEvent event) {
    if (event is RoomMessageEvent) {
        onMessage(event);
    }
});
```
</CodeGroup>


The `RoomMessage` object includes:

- `from_participant_id`: the sender’s participant ID (string).
- `type`: the message type (e.g., `"my_message_type"`).
- `message`: a Python dictionary with the JSON payload.
- `attachment`: the raw bytes if a file or other binary data was attached.

### Broadcasting Messages

To send a message to **all** participants, call:

<CodeGroup>
```python Python
await room.messaging.broadcast_message(
    type="my_broadcast_type",
    message={"hello": "everyone"},
    attachment=None
)
```
```javascript JavaScript
await room.messaging.broadcastMessage({
    type: "my_broadcast_type",
    message: { hello: "everyone" },
});
```
```typescript TypeScript
await room.messaging.broadcastMessage({
    type: "my_broadcast_type",
    message: { hello: "everyone" },
});
```
```dart Dart
await room.messaging.broadcastMessage(
    type: "my_broadcast_type",
    message: { "hello": "everyone" }
);
```
</CodeGroup>


All participants with messaging enabled will receive this broadcast.

---

## Example With Two Agents

Below is a complete example showing **two separate participants** (we’ll call them “Alice” and “Bob”) who each connect to the same room. Then Alice sends a message to Bob, Bob replies, and each one prints the message.

> **Note**: This example starts both participants in the same Python script for demo purposes. In practice, each participant (or agent) can be in a separate process or even on a different machine, as long as they connect to the same room.


<CodeGroup>
    <MessagingSent />
</CodeGroup>


### How This Example Works

1. **Two connections**: We create two separate `RoomClient` connections, one for “Alice” and one for “Bob.” Each uses a unique `ParticipantToken` but shares the same `room_name`.
2. **Enable messaging**: We call `room.messaging.enable()` in both so each can send and receive custom messages.
3. **Send message**: From “Alice”’s room, we look up “Bob” in `room.messaging.remote_participants`, then call `send_message(...)`.
4. **Receive message**: “Bob” receives the message in the event callback:

<CodeGroup>
```python Python
def on_message(message):
   print(f"[Bob] Received a message from {message.from_participant_id}: {message.message}")
```
</CodeGroup>
   
5. **Reply**: “Bob” then sends a message back to “Alice” by looking up her participant object in his local list.

6. **Tear down**: We eventually close both connections.

---

## Additional Notes

- If you want to **broadcast** a message to all participants in the room, use:
  
<CodeGroup>
```python Python
await room.messaging.broadcast_message(
  type="global_announcement",
  message={"text":"Hello everyone!"}
)
```
</CodeGroup>

- You can also send **binary data** in the `attachment` argument if you need to transfer files or other binary payloads.
- For advanced use-cases such as streaming large data chunk-by-chunk, refer to the `MessageStreamReader` / `MessageStreamWriter` APIs (`create_stream`, etc.).

With this, you have all the essential building blocks to exchange messages (text or binary) among participants or agents using the MeshAgent client API.

