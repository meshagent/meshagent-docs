---
title: Packaging and Deploying Services
---
import ServiceSpecChatbot from "/snippets/examples/packaging/service_chatbot.mdx"
import ServiceTemplateChatbotMailbot from "/snippets/examples/packaging/service_template_chatbot_mailbot.mdx"

MeshAgent allows you to deploy any code as a service. Services can be anything from pre-built agents to custom code to external integrations and can be deployed as either a room service (scoped to a specific MeshAgent room) or a project service (available in every room in your project). 

To deploy a service, you'll need a YAML configuration file that defines how your service should run. This configuration file will reference either:
- **A container**: Use MeshAgent's pre-built containers or build your own custom image
- **An external URL**: Point to a service you're already running elsewhere

In this guide, we'll cover the basics of packaging and deploying services with complete examples and include a field reference for creating the YAML configuration file. 

## Key Concepts
MeshAgent services can be deployed using the MeshAgent CLI, from [MeshAgent Studio](https://studio.meshagent.com), or by [sharing an Powerboards install link](./share_agents_in_powerboards). Before deploying, you'll make three decisions about your service:
### 1. Where Does It Run?
**Project Services:**
- Available in **every room** in your project
- Changes require room restart to take effect
- Best for: Shared functionality (transcription, compliance agents, common tools)
- Deploy with: `meshagent service create --file meshagent.yaml` or  `meshagent service create-template --file meshagent.yaml` (no `--room` flag)

**Room Services:**
- Scoped to a **specific room**
- Auto-update if changed during an active session
- Best for: User customizable agents, room-specific integrations
- Deploy with: `meshagent service create --file meshagent.yaml --room myroom` or `meshagent service create-template --file meshagent.yaml --room myroom`

### 2. How Is It Configured?
The choice between `Service` and `ServiceTemplate` depends on whether users need to customize your service at deployment time. A `Service` runs as-is. A `ServiceTemplate` collects user inputs, then MeshAgent calls `to_service_spec()` to generate the actual `Service` that runs.

**Service (`kind: Service`):**
- Fixed configuration that runs as-is
- Best for: CI/CD deployments, predetermined settings
- Deploy with: `meshagent service create...`

**ServiceTemplate (`kind: ServiceTemplate`):**
- Users provide values (API keys, prompts, emails) at deploy time
- Best for: Customizable services, user-supplied configuration
- Deploy with: `meshagent service create-template`

### 3. How Does It Run?
**Containerized Services (`container:`):**
- MeshAgent runs your container image in the room
- Best for: MeshAgent native agents or custom use cases
- Requires: Container image (public or private registry)

**External Services (`external:`):**
- Point to a service you host elsewhere
- Best for: Existing services, infrastructure you already run
- Requires: Publicly accessible URL

## Example: Deploy an agent from the MeshAgent CLI 
All MeshAgent's prebuilt agents ([ChatBot](../agents/standard/chatbot), [MailBot](../agents/standard/mailbot), [VoiceBot](../agents/standard/voicebot), [TaskRunner](../agents/standard/taskrunner), and [Worker](../agents/standard/worker)) can be deployed directly from the CLI. Using the `meshagent <agent_type> deploy` command. This command will generate the service configuration for the agent and deploy it for you. 

For example, to deploy a basic ChatBot with web search and storage tools run: 
```bash
meshagent setup # Authenticate to MeshAgent

meshagent chatbot deploy \
  --service-name my-chatbot \
  --service-description "Chatbot with web search and storage tools" \
  --agent-name my-chatbot \
  --rule "You are a helpful assistant" \
  --require-web-search \
  --require-storage \
  --path /chat \
  --room myroom
```

Alternatively, you can use the CLI to generate the service configuration YAML for you, save the configuration as a `meshagent.yaml` file, then deploy it. For example: 

```bash
meshagent chatbot spec \
  --service-name my-chatbot \
  --service-description "Chatbot with web search and storage tools" \
  --agent-name my-chatbot \
  --rule "You are a helpful assistant" \
  --require-web-search \
  --require-storage \
  --path /chat 
```

Then save the result and deploy it by running `meshagent service create --file=meshagent.yaml`. 

### Example 2: ServiceSpec YAML (Containerized Chatbot)
Create a `meshagent.yaml` by hand and deploy it with `meshagent service create`.

<CodeGroup>
  <ServiceSpecChatbot />
</CodeGroup>

Deploy it:

```bash
meshagent service validate --file meshagent.yaml
meshagent service create --file meshagent.yaml --room myroom
```

### Example 3: ServiceTemplate YAML (Chatbot + Mailbot)
Use a template when users must supply values at deployment time.

<CodeGroup>
  <ServiceTemplateChatbotMailbot />
</CodeGroup>

Values file example:

```yaml
support_email: support@company.com
```

Deploy it:

```bash
meshagent service validate-template --file meshagent.template.yaml
meshagent service create-template --file meshagent.template.yaml --values-file meshagent.values.yaml --room myroom
```

## Field Reference

### Configuration Overview
| Field | Required | Used By | Description |
|-------|----------|---------|-------------|
| `version` | Yes | Both | Always "v1" |
| `kind` | Yes | Both | "Service" or "ServiceTemplate" |
| `metadata` | Yes | Both | Service identity and display information |
| `agents` | No | Both | Register the agent identities exposed by the service |
| `ports` | No | Both | Endpoints MeshAgent can call |
| `container` | * | Both | Container configuration (mutually exclusive with `external`) |
| `external` | * | Both | External service URL (mutually exclusive with `container`) |
| `variables` | No | ServiceTemplate only | User inputs for templating |

> **\* Either `container` or `external` is required, but not both.**

### Metadata
The metadata section identifies your service and provides information displayed in the UI.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Unique service name |
| `description` | string | No | Description shown in UI |
| `repo` | string | No | Source code repository URL |
| `icon` | string | No | Icon/emoji for UI display |
| `annotations` | object | No | Custom key-value metadata (for example `meshagent.service.id` or `meshagent.service.readme`) |

### Agents
Use the `agents` list to declare the MeshAgent identities your service provides. This helps MeshAgent route requests, apply agent-specific policies, and present the right agents in the UI.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Unique agent identity within the service |
| `description` | string | No | Display text describing the agent |
| `annotations` | object | No | Key-value metadata about the agent (for example `meshagent.agent.type`) |

Scheduled tasks are configured using the `meshagent.agent.schedule` annotation. The value is a JSON string that defines the schedule and queued message payload.

### Ports
Define how MeshAgent connects to your service. Each port can expose multiple endpoints.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `num` | `"*"` or int | Yes | Port number or `"*"` for auto-assignment |
| `host_port` | int | No | Host port mapping for the container port (defaults to `num`) |
| `type` | string | No | Protocol type: `http` or `tcp` |
| `liveness` | string | No | Path for health checks |
| `endpoints` | list | No | List of endpoints this port serves |
| `published` | boolean | No | Publish the port to the internet (useful for webhooks) |
| `public` | boolean | No | When false, requests must include a participant token |

### Endpoints
Each endpoint must specify a `path` and either `meshagent` or `mcp` configuration.

**MeshAgent Endpoints**

For MeshAgent native services built with `ServiceHost`.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `identity` | string | Yes | Participant identity for the endpoint |
| `api` | object | No | API scope overrides (see [API Scopes](../rest_api/api_scopes)) |

**MCP Endpoints**

For Model Context Protocol (MCP) servers.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `label` | string | Yes | Display name for the MCP server |
| `description` | string | No | Description of what the server provides |
| `allowed_tools` | list | No | Filter which tools are available |
| `headers` | object | No | Custom headers to include |
| `require_approval` | string | No | "always" or "never" |
| `oauth` | object | No | OAuth configuration |
| `openai_connector_id` | string | No | OpenAI connector ID |

`allowed_tools` entries:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `tool_names` | list | Yes | Tool names to allow |
| `read_only` | boolean | No | Whether tools should be treated as read-only |

**OAuth Configuration with MCP**

The `oauth` field allows you to define an OAuth configuration for the MCP server.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `client_id` | string | Yes | OAuth client ID |
| `client_secret` | string | No | OAuth client secret |
| `authorization_endpoint` | string | Yes | OAuth authorization endpoint URL |
| `token_endpoint` | string | Yes | OAuth token endpoint URL |
| `no_pkce` | boolean | No | Whether to disable PKCE (Proof Key for Code Exchange) |
| `scopes` | list | No | List of OAuth scopes to request |

### External
Use `external` when your service is already running elsewhere. MeshAgent will route calls to the URL you provide.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `url` | string | Yes | URL where the service is running |

### Container
Use `container` when MeshAgent should run your service in a container. Containers can be used with both `ServiceSpec` and `ServiceTemplateSpec`. However, only containers started by the room as a service can use secrets, which prevents a user from dynamically pulling private images they do not have access to.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `image` | string | Yes | Container image (e.g., `registry/image:tag`) |
| `command` | string | No | Override container entrypoint |
| `environment` | list | No | Environment variables |
| `secrets` | list | No | Secret IDs to inject as environment variables (`ServiceSpec` only) |
| `pull_secret` | string | No | Secret ID for accessing private registries (`ServiceSpec` only) |
| `storage` | object | No | Mount room or project storage |
| `api_key` | object | No | Auto-provision API key for the service (`ServiceSpec` only) |
| `on_demand` | boolean | No | Run only when explicitly invoked (per-request services) |
| `writable_root_fs` | boolean | No | Allow writes to the container root filesystem (default: read-only) |
| `private` | boolean | No | Mark the container as private to its service (default: true) |

ServiceTemplate containers support `image`, `command`, `environment`, `storage`, `on_demand`, `writable_root_fs`, and `private`.

#### Environment Variables
Environment variables can be literal values or request a participant token to be injected.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Environment variable name |
| `value` | string | No | Literal value |
| `token` | object | No | Inject a participant token instead of a literal value |

`token` fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `identity` | string | Yes | Participant identity to issue the token for |
| `api` | object | No | API scope for the token (see [API Scopes](../rest_api/api_scopes)) |

#### Storage
Use the `storage` field to mount room, project, image, or file storage into your container.

Storage mount types:
- Room storage: per-room files (read/write by default)
- Project storage: shared across all rooms (read-only by default)
- Image storage: read-only mounts from another container image
- File storage: inline text mounted as a file

`storage` fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `room` | list | No | Room storage mounts |
| `project` | list | No | Project storage mounts |
| `images` | list | No | Image storage mounts |
| `files` | list | No | File storage mounts |

Room and project mount fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `path` | string | Yes | Mount path inside the container |
| `subpath` | string | No | Subdirectory within the storage volume |
| `read_only` | boolean | No | Whether the mount is read-only |

Image mount fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `image` | string | Yes | Source image for `storage.images` mounts |
| `path` | string | Yes | Mount path inside the container |
| `subpath` | string | No | Subdirectory within the image |
| `read_only` | boolean | No | Whether the mount is read-only |

File mount fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `path` | string | Yes | Mount path inside the container |
| `text` | string | Yes | File contents |
| `read_only` | boolean | No | Whether the mount is read-only |

#### API Key Provisioning
The `api_key` field allows your container service to request an admin API key be automatically provisioned and injected. This is useful when your service needs to call MeshAgent APIs directly (for example to manage participants, create resources, or call admin-only endpoints).

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `role` | string | Yes | Always "admin" |
| `name` | string | Yes | Name for the API key |
| `auto_provision` | boolean | No | Auto-provision on deployment |

### Variables (ServiceTemplate only)
Variables define what values users can provide when a container-based service launches. You can restrict inputs or hide sensitive ones. Template substitutions use Jinja. Use `{{ variable_name }}` placeholders in any string field, or prefix a value with `!template` when you need explicit templating for a block scalar or value that includes curly braces.

Templating is supported in metadata fields, agents, `container.image`, `container.command`, `container.environment` values, and `external.url`.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Variable identifier used in `{{ variable_name }}` templates |
| `description` | string | No | Help text shown in the UI |
| `enum` | list | No | Restrict to specific values (dropdown displayed in UI) |
| `optional` | boolean | No | Whether the variable is required |
| `obscure` | boolean | No | Hide the value in the UI (for sensitive data) |
| `type` | string | No | Type hint (for example `email`). Set to `email` if creating an email address |
| `annotations` | object | No | Custom metadata for the variable |

## Advanced Deployment Patterns
- [Base image + custom script](./advanced_deployment_patterns/base_image_custom_script)
- [Base image + code image mount](./advanced_deployment_patterns/base_image_code_mount)
- [Custom container build and push](./advanced_deployment_patterns/custom_container_build)
- [External service hosted elsewhere](./advanced_deployment_patterns/external_service)
- [External MCP service](./advanced_deployment_patterns/external_mcp_service)
